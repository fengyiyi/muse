// Generated by CoffeeScript 1.3.1
(function() {
  var LOCATION_DIR, app, file, fs, http, io, json, locationName, locationNames, locations, paperboy, _i, _len;

  http = require('http');

  paperboy = require('paperboy');

  io = require('socket.io');

  fs = require('fs');

  LOCATION_DIR = 'store/';

  locationNames = ['dc'];

  locations = {};

  for (_i = 0, _len = locationNames.length; _i < _len; _i++) {
    locationName = locationNames[_i];
    file = LOCATION_DIR + locationName + '.json';
    json = fs.readFileSync(file);
    try {
      json = JSON.parse(json);
    } catch (e) {
      json = {
        dirty: false,
        lastChanged: new Date(),
        drawers: {}
      };
    }
    locations[locationName] = json;
  }

  setInterval((function() {
    var locationName, _fn, _j, _len1;
    _fn = function(locationName) {
      var data, locationSpec;
      locationSpec = locations[locationName];
      if (!locationSpec.dirty) {
        return;
      }
      file = LOCATION_DIR + locationName + '.json';
      data = JSON.stringify(locationSpec, null, 2);
      fs.writeFile(file, data, function(err) {
        if (err) {
          console.error("There was an error writing the file [" + file + "]", err);
        } else {
          console.log('Location file saved');
          locationSpec.dirty = false;
        }
      });
    };
    for (_j = 0, _len1 = locationNames.length; _j < _len1; _j++) {
      locationName = locationNames[_j];
      _fn(locationName);
    }
  }), 2000);

  app = http.createServer(function(req, res) {
    paperboy.deliver(__dirname + '/public', req, res).addHeader('X-PaperRoute', 'Node').before(function() {
      return console.log('Received Request');
    });
  });

  io = io.listen(app);

  app.listen(8181);

  io.sockets.on('connection', function(socket) {
    var client;
    client = {};
    socket.on('addClient', function(locationStr) {
      var location;
      client.location = locationStr;
      location = locations[client.location];
      socket.join(client.location);
      socket.emit('updateDrawers', location.drawers);
    });
    socket.on('drawerChange', function(drawer, state) {
      var location;
      location = locations[client.location];
      location.drawers[drawer] = state;
      socket.broadcast.to(client.location).emit('drawerChange', drawer, state);
      location.dirty = true;
    });
  });

}).call(this);
